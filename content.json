[{"title":"Kotlin入门：Kotlin介绍","date":"2018-06-02T05:14:52.000Z","path":"2018/06/02/kotlin/Kotlin介绍/","text":"什么是Kotlin？由 JetBrains 公司开发，2017 Google I/O成为Android官方支持开发语言，开源语言 Kotlin特性 开源 可以编译成Java字节码，也可以编译成JavaScript，运行于JVM或JavaScript环境 JDK兼容，混合Java + Kotlin项目的互操作性和无缝支持 IntelliJ IDEA，Android Studio、Eclipse 多种开发工具支持 语法更简洁、安全、易扩展、对初学者友好 Kotlin语法定义包名在源文件的开头定义包名： 123package my.demoimport java.util.*//... 包名不必和文件夹路径一致：源文件可以放在任意位置 定义函数定义一个函数接受两个 int 型参数，返回值为 int ： 123fun sum(a: Int , b: Int) : Int&#123; return a + b&#125; 定义main函数 1234fun main(args: Array&lt;String&gt;) &#123; print(\"sum of 3 and 5 is \") println(sum(3, 5))&#125; 定义局部变量常量用val声明，变量用var声明，关键字在前面，类型以冒号:隔开在后面，也可以省略直接赋值，类型后带问号?表示可为空类型(默认空安全) 12345678910111213fun main(args: Array&lt;String&gt;) &#123; val a: Int = 1 // 立即初始化 val b = 2 // 推导出Int型 val c: Int // 当没有初始化值时必须声明类型 c = 3 // 赋值 println(\"a = $a, b = $b, c = $c\") //空安全变量 var str: String = \"hello\" var str1 = \"word\" //可为空字符串变量 var str2: String? = null&#125; 注释与 java 和 javaScript 一样，Kotlin 支持单行注释和块注释 1234// 单行注释/* 哈哈哈哈 这是块注释 */ 字符串模板12345678910fun main(args: Array&lt;String&gt;) &#123; var a = 1 // 使用变量名作为模板: val s1 = \"a is $a\" a = 2 // 使用表达式作为模板: val s2 = \"$&#123;s1.replace(\"is\", \"was\")&#125;, but now is $a\" println(s2)&#125; 使用条件表达式1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 把if当表达式 1fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b 使用循环for循环 12345fun main(args: Array&lt;String&gt;) &#123; val items = listOf(\"apple\", \"banana\", \"kiwi\") for (item in items) &#123; println(item)&#125; while 循环 12345678fun main(args: Array&lt;String&gt;) &#123; val items = listOf(\"apple\", \"banana\", \"kiwi\") var index = 0 while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++ &#125;&#125; 使用 when 表达式移除了switch用更强大的when替代，when子式可以是常量、变量、返回数值的表达式、返回Boolean值的表达式 123456789101112var x = 10when (x) &#123; //常量 2 -&gt; println(\"=2\") //数值表达式 if (x &gt; 0) 1 else -1 -&gt; println(\"大于0并等于1，或小于0并等于-1\") //Boolean类型表达式 in 1..5 -&gt; println(\"1-5\") !in 6..9 -&gt; println(\"6-9\") is Int -&gt; println(\"判断类型\") else -&gt; println(\"否则\")&#125; 使用集合对一个集合进行迭代 123456fun main(args: Array&lt;String&gt;) &#123; val items = listOf(\"apple\", \"banana\", \"kiwi\") for (item in items) &#123; println(item) &#125;&#125; 使用lambda表达式过滤和映射集合： 12345678fun main(args: Array&lt;String&gt;) &#123; val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwi\") fruits .filter &#123; it.startsWith(\"a\") &#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;&#125; 相关链接 在线写Kotlin Kotlin中文文档","tags":[{"name":"Kotlin入门","slug":"Kotlin入门","permalink":"https://linsage.com/tags/Kotlin入门/"}]},{"title":"IntelliJ IDEA插件开发","date":"2018-01-10T09:52:19.000Z","path":"2018/01/10/技术/IntelliJ IDEA插件开发/","text":"需求Java Bean 类转换json，粘贴到Postman上调试 准备环境 IntelliJ IDEA Community（社区免费版） JDK 1.8 基础配置 plugin.xml：配置插件信息，主要配置antAction对应，文件右键弹出菜单 Java2JsonAction：主代码文件 效果图 插件地址Java Bean to Json","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"工具","slug":"工具","permalink":"https://linsage.com/tags/工具/"}]},{"title":"快速配置https","date":"2017-11-02T10:08:01.000Z","path":"2017/11/02/技术/快速配置https/","text":"由于微信平台要求接口使用HTTPS，各大网站开始推广HTTPS化。 本文介绍如何低成本快速部署使用https 步骤 安装acme.sh 申请证书 安装证书 配置nginx 检查和校验 安装acme.shacme.sh 实现了 acme 协议, 可以从 Let’s Encrypt 生成免费的证书，自动利用crontab自动更新证书。 curl https://get.acme.sh | sh source ~/.bashrc 申请证书acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证， http 验证我用的是http验证方式，我用的nginx服务器,acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录: acme.sh --issue -d example.com --nginx 目前let’s encrypt只信任80和443端口，nginx必须监听80端口，完成验证 dns 验证添加txt记录 https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md 结果 安装证书注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/ 1234acme.sh --installcert -d api.linsage.xyz \\ --key-file /usr/local/nginx/ssl/api.linsage.xyz.key \\ --fullchain-file /usr/local/nginx/ssl/api.linsage.xyz.cer \\ --reloadcmd &quot;service nginx force-reload&quot; openssl dhparam -out dhparams.pem 4096 统一放目录：/usr/local/nginx/ssl/ 配置nginx1234567891011121314151617181920212223242526272829server &#123; listen 80; server_name api.linsage.xyz; return 301 https://$server_name$request_uri; &#125; server &#123; listen 443; server_name api.linsage.xyz; ssl on; ssl_certificate /usr/local/nginx/ssl/api.linsage.xyz.cer; ssl_certificate_key /usr/local/nginx/ssl/api.linsage.xyz.key; ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_stapling on; ssl_stapling_verify on; ssl_prefer_server_ciphers on; ssl_dhparam /usr/local/nginx/ssl/dhparam.pem; add_header Strict-Transport-Security max-age=15552000; location /&#123; root html; &#125; &#125; 检查评级https://www.ssllabs.com","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"}]},{"title":"Nginx安装","date":"2017-11-02T07:07:53.000Z","path":"2017/11/02/技术/Nginx安装/","text":"Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。 安装依懒库检查安装nginx的依赖库 编译需要 gcc-c++ gzip 模块需要 zlib 库 ( 下载: http://www.zlib.net/ ) rewrite 模块需要 pcre 库 ( 下载: http://www.pcre.org/ ) ssl 功能需要 openssl 库 ( 下载: http://www.openssl.org/ ) apt-get install -y build-essentialapt-get install -y zlibc zlib1g zlib1g-devapt-get install -y libpcre3 libpcre3-devapt-get install -y libssl-dev 安装nginx 下载 wget http://nginx.org/download/nginx-1.12.2.tar.gz 解压 tar -zxvf nginx-1.12.2.tar.gz 进去目录，执行 ./configure --with-http_ssl_module 编译安装 make &amp; make install 默认安装在 /usr/local/nginx 下 配置nginx 默认配置文件：/usr/local/nginx/conf/nginx.conf 启动命令：/usr/local/nginx/sbin/nginx 1234567891011121314151617http &#123; include mime.types; default_type application/octet-stream; server &#123; listen 23285; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125;&#125; 作为系统服务vi /etc/init.d/nginx 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash## chkconfig: - 85 15# description: Nginx is a World Wide Web server.# processname: nginxnginx=/usr/local/nginx/sbin/nginxconf=/usr/local/nginx/conf/nginx.confcase $1 instart)echo -n &quot;Starting Nginx&quot;$nginx -c $confecho &quot; done&quot;;;stop)echo -n &quot;Stopping Nginx&quot;killall -9 nginxecho &quot; done&quot;;;test)$nginx -t -c $conf;;reload)echo -n &quot;Reloading Nginx&quot;ps auxww | grep nginx | grep master | awk &apos;&#123;print $2&#125;&apos; | xargs kill -HUPecho &quot; done&quot;;;restart)$0 stop$0 start;;show)ps -aux|grep nginx;;*)echo -n &quot;Usage: $0 &#123;start|restart|reload|stop|test|show&#125;&quot;;;esac chmod +x /etc/init.d/nginxupdate-rc.d nginx defaultsservice nginx start 检查防火墙12iptables -nL --line-numbersiptables -A INPUT -p tcp --dport 23285 -j ACCEPT 效果","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"}]},{"title":"Chrome Headless模式","date":"2017-08-03T03:27:26.000Z","path":"2017/08/03/技术/Chrome Headless模式/","text":"Google Chrome 浏览器59+版本包含headless模式，该模式运行不需要任何显示命令支持。简单来说，服务器上能跑无界面的Chrome浏览器。 解决了什么问题 网页爬虫 自动化测试 自动截图 … 安装1234sudo apt-get install libxss1 libappindicator1 libindicator7wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome*.deb # Might show \"errors\", fixed by next linesudo apt-get install -f 启动 Chrome123# https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md# --disable-gpu currently required, see link abovegoogle-chrome --headless --hide-scrollbars --remote-debugging-port=9222 --disable-gpu &amp; 使用 Node.jschrome-remote-interface 使用 Javaheadless-chrome gradle配置123456789101112131415apply plugin: 'java'sourceCompatibility = 1.8repositories &#123; repositories &#123; maven &#123; url 'https://maven.reinvent-software.de/nexus/content/groups/public/' &#125; &#125; repositories &#123; maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125; &#125; mavenLocal() mavenCentral()&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.11' compile 'software.reinvent:headless-chrome:0.3.0'&#125; 配置文件chrome路径1webdriver.chrome.binary: &quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot; Main文件1234567891011public static void main(String[] args) throws Exception &#123; //读取配置 Config config = new ConfigProvider().get(); ChromeDriver driver = new HeadlessChromeProvider(config).get(); driver.get(\"http://www.qq.com\"); //截图 File file = driver.getScreenshotAs(OutputType.FILE); System.out.println(file.getPath()); //退出 driver.quit();&#125; 效果状态 截图","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"chrome","slug":"chrome","permalink":"https://linsage.com/tags/chrome/"}]},{"title":"构建自己的Chrome扩展","date":"2017-07-20T02:06:29.000Z","path":"2017/07/20/技术/构建自己的Chrome扩展/","text":"Chrome扩展是用于扩充Chrome浏览器的程序，主用于对浏览器功能的增强。Chrome扩展和Chrome应用有很多相似之处，Chrome应用强调独立的程序，有更多的底层的系统接口和权限，Chrome扩展只能运行于浏览器，强调和浏览器结合。 需求由于使用gitlab社区版搭建git仓库，本身gitlab没有左侧代码目录树视图，繁琐的跳转才能预览和审视代码视图。 Manifest文件格式Chrome扩展一个Manifest文件，整个扩展的入口。 格式：Manifest文件 开发技巧 基础前端知识 浏览学习其他插件的源码 善于利用自带调试窗口 Chrome扩展及应用开发Chrome扩展开发文档Chrome扩展官方文档 应用发布应用写好后打包上传，提供相关信息。开发者信息中心注册，要选择HK，一张VISA信用卡，交纳5美刀认证。等待几小时审核后，就可以在市场上看到自己的应用啦！ 效果 下载地址 Github","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"chrome","slug":"chrome","permalink":"https://linsage.com/tags/chrome/"}]},{"title":"Java常量类生成器","date":"2017-07-04T09:22:31.000Z","path":"2017/07/04/技术/Java常量类生成器/","text":"需求 properties配置文件，创建常量类 常量类创建后，繁多设置属性值 配置文件变更和常量类不同步，容易遗漏 特点 支持自动生成常量类 ConfigGenerator 支持无限树形结构生成，基础数据类型（默认String，自定义属性type） 支持自动设置值 ConfigLoader 作用：只需维护properties文件，自动生成类和设置属性值 项目地址：https://github.com/linsage/constant-generator 示例config.properties 配置文件12345678910111213141516171819202122232425262728name=linsagedevMode=truedevMode.type=boolean#数据库db.url=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNulldb.user=rootdb.password=123456#druiddruid.initialSize=10druid.minIdle=10druid.maxActive=100#监控页面druid.visitPath=/zs#慢sqldruid.logSlowSql=truedruid.slowSqlMillis=100#qiuniuqiniu.accessKey=123456qiniu.secretKey=56788qiniu.separator=_qiniu.bucket=test1qiniu.domain=http://1.bkt.clouddn.comqiniu.ins.bucket=test2qiniu.ins.domain=http://2.bkt.clouddn.com#proxyhttpProxy.ip=127.0.0.1httpProxy.port=8118httpProxy.port.type=int ConfigGenerator 配置文件生成常量类123456789101112131415public static void main(String[] args) &#123; /** * 生成常量类 */ // base model 文件保存路径 String outputDir = PathKit.getWebRootPath() + \"/../src/main/java/xyz/linsage/model\"; //包名 String packageName = \"xyz.linsage.model\"; //类名 String className = \"Constant\"; ConfigGenerator g = new ConfigGenerator(packageName, className, outputDir); //带顺序，为了和配置文件一致 LinkedProp prop = LinkedPropKit.use(\"config.properties\"); g.generate(prop.getProperties());&#125; 生成类12345678910111213141516171819202122232425262728293031323334353637383940414243package xyz.linsage.model;/** * Generated by linsage, do not modify this file. */@SuppressWarnings(\"serial\")public class Constant &#123; public static String name; public static boolean devMode; public static class db &#123; public static String url; public static String user; public static String password; &#125; public static class druid &#123; public static String initialSize; public static String minIdle; public static String maxActive; public static String visitPath; public static String logSlowSql; public static String slowSqlMillis; &#125; public static class qiniu &#123; public static String accessKey; public static String secretKey; public static String separator; public static String bucket; public static String domain; public static class ins &#123; public static String bucket; public static String domain; &#125; &#125; public static class httpProxy &#123; public static String ip; public static int port; &#125;&#125; ConfigLoader 自动加载配置文件属性值123456789101112public static void main(String[] args) &#123; LinkedProp prop = LinkedPropKit.use(\"config.properties\"); ConfigLoader configLoader = new ConfigLoader(); configLoader.load(Constant.class, prop.getProperties()); System.out.println(Constant.name); System.out.println(Constant.devMode); System.out.println(Constant.db.url); System.out.println(Constant.qiniu.ins.domain); System.out.println(Constant.httpProxy.port); System.out.println(\"ok\");&#125;","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"java","slug":"java","permalink":"https://linsage.com/tags/java/"}]},{"title":"hexo中实现ins相册功能","date":"2017-06-19T06:47:43.000Z","path":"2017/06/19/技术/hexo中实现ins相册功能/","text":"hexo主题搭建博客，最终生成静态网页形式展示。 想要获取instagram信息，在博客中实现相册功能。 选择一个hexo主题hexo的主题很多，个人推荐简约和性能，支持手机浏览的主题。 推荐yilia 了解hexo文件目录 如图所示，photos目录下，存放着相册功能所有前端资源。其中关键是ins.json数据与ins.js显示逻辑。ins.js依靠ins.json内容信息控制显示。 问题如何生成ins.json内容？ 抓取ins生成内容问题 纯静态页面，不可能动态更新ins.json instagram国内被和谐，不访问相关图片资源 解决 借助后端Java能力，抓取ins信息 图片转存七牛，实现访问 实现项目地址：https://github.com/linsage/ins-to-qiniu博客配置：https://github.com/linsage/blog-backup 1. 通过ins的api获取账号下信息并缓存国内环境，可能借助代理才能实现请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取图文信息json * * @param username */ private JSONArray getEdges(String username) &#123; //先从缓存读取 JSONArray array = CacheKit.get(\"userPhoto\", username); if (array != null) return array; //1.获取userId String url = \"https://www.instagram.com/\" + username + \"/?__a=1\"; //由于墙外地址，使用代理（请自行修改） OkHttpClient okHttpClient = new OkHttpClient().newBuilder().proxy((new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"127.0.0.1\", 8118)))).build(); Request request = new Request.Builder().url(url).build(); Call call = okHttpClient.newCall(request); try &#123; Response response = call.execute(); JSONObject jsonObject = JSONObject.parseObject(response.body().string()); String userId = ((JSONObject) jsonObject.get(\"user\")).get(\"id\").toString(); //System.out.println(jsonObject.toJSONString()); //2.获取内容 String contentUrl = \"https://www.instagram.com/graphql/query/?query_id=17880160963012870&amp;id=\" + userId + \"&amp;first=999\"; request = new Request.Builder().url(contentUrl).build(); response = okHttpClient.newCall(request).execute(); jsonObject = JSONObject.parseObject(response.body().string()); //System.out.println(jsonObject.toJSONString()); //data.user.edge_owner_to_timeline_media.edges array = jsonObject .getJSONObject(\"data\") .getJSONObject(\"user\") .getJSONObject(\"edge_owner_to_timeline_media\") .getJSONArray(\"edges\"); //设置缓存（k-username,V-图文） CacheKit.put(\"userPhoto\", username, array); return array; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; 2. 下载ins图片并上传到七牛云123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 下载ins，返回相册json * * @throws Exception */ public void downloadIns() throws Exception &#123; String username = getPara(\"username\"); JSONArray array = getEdges(username); //结果map（k-年月，v-内容） Map&lt;String, JSONArray&gt; nodeMap = new LinkedHashMap&lt;&gt;(); if (array != null) &#123; //不为空，下载图片 for (int i = 0; i &lt; array.size(); i++) &#123; JSONObject node = array.getJSONObject(i).getJSONObject(\"node\"); //时间 int timestamp = node.getIntValue(\"taken_at_timestamp\"); Date date = DateKit.getDateByUnixTime(timestamp); //code final String code = node.getString(\"shortcode\"); //标题 final String title = node.getJSONObject(\"edge_media_to_caption\").getJSONArray(\"edges\").getJSONObject(0).getJSONObject(\"node\").getString(\"text\"); //图片地址 final String url = node.getString(\"display_url\"); final String extension = url.substring(url.lastIndexOf(\".\")); final String fileName = code + extension; final String saveDir = PathKit.getWebRootPath() + File.separator + \"ins\"; //年-月-1 final String key = DateKit.dateFormat(date, \"yyyy-MM-1\"); JSONObject obj = new JSONObject(); obj.put(\"timestamp\", timestamp); obj.put(\"url\", Constant.Qiniu.domain + \"/\" + fileName); obj.put(\"title\", title); obj.put(\"type\", \"image\"); if (!nodeMap.containsKey(key)) &#123; nodeMap.put(key, new JSONArray()); &#125; nodeMap.get(key).add(obj); DownloadKit.get().download(url, fileName, saveDir, new DownloadKit.OnDownloadListener() &#123; @Override public void onDownloadSuccess() &#123; System.out.println(\"onDownloadSuccess：\" + code); //成功下载，上传到七牛云 QiniuKit.get().upload(new File(saveDir + File.separator + fileName), new QiniuKit.OnUploadListener() &#123; @Override public void onUploadSuccess() &#123; System.out.println(\"onUploadSuccess\" + code); System.out.println(Constant.Qiniu.domain + \"/\" + fileName); &#125; @Override public void onUploadFailed() &#123; System.out.println(\"onUploadFailed\" + code); &#125; &#125; ); &#125; @Override public void onDownloading(int progress) &#123; &#125; @Override public void onDownloadFailed() &#123; System.out.println(\"onDownloadFailed：\" + code); &#125; &#125;); &#125; &#125; //ins.json JSONObject result = new JSONObject(); JSONArray list = new JSONArray(); for (Map.Entry&lt;String, JSONArray&gt; entry : nodeMap.entrySet()) &#123; String key = entry.getKey(); JSONArray value = entry.getValue(); // now work with key and value... Date date = DateKit.convertToDate(key); Calendar cal = Calendar.getInstance(); cal.setTime(date); int year = cal.get(Calendar.YEAR); int month = cal.get(Calendar.MONTH) + 1; JSONObject item = new JSONObject(); item.put(\"year\", year); item.put(\"month\", month); item.put(\"arr\", value); list.add(item); &#125; result.put(\"list\", list); renderJson(result); &#125; 3. ins.js根据ins.json内容进行显示，配置相册目录入口最终效果","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"hexo","slug":"hexo","permalink":"https://linsage.com/tags/hexo/"}]},{"title":"socks5代理转http代理","date":"2017-06-13T07:16:04.000Z","path":"2017/06/13/技术/Socks5代理转Http代理/","text":"通用shadowsocks提供socks5，实现科学上网，但是没提供http代理，除了浏览器外，很多软件和开发上需要请求墙外的地址，这些没有提供socks5的代理，需要http代理来实现访问。 安装shadowsocks客户端shadowsocks不区分服务端和客户端，根据启动脚本 sslocal代表以客户端模式工作 ssserver代表以服务器端模式工作 12yum install python-pippip install shadowsocks 1touch /etc/shadowsocks.json { “server”:”your_server_ip”, #ss服务器IP “server_port”:your_server_port, #端口 “local_address”: “127.0.0.1”, #本地ip “local_port”:1080, #本地端口 “password”:”your_server_passwd”,#连接ss密码 “timeout”:300, #等待超时 “method”:”rc4-md5”, #加密方式 “fast_open”: false, # true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可 “workers”: 1 # 工作线程数} 123nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;echo &quot; nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;&quot; /etc/rc.localps aux |grep sslocal |grep -v &quot;grep&quot; 安装PrivoxyPrivoxy是一款带过滤功能的代理服务器，针对HTTP、HTTPS协议。通过Privoxy的过滤功能，用户可以保护隐私、对网页内容进行过滤、管理cookies，以及拦阻各种广告等，支持全平台。 需要用到的功能就是它的socks转换功能，将socks转换为可用的http方式。 命令安装 1brew install privoxy 源码安装 123456tar -zxvf privoxy-3.0.24-stable-src.tar.gzcd privoxy-3.0.24-stableuseradd privoxyautoheader &amp;&amp; autoconf./configuremake&amp;&amp;make install 配置Privoxy1. 确认本地shadowsocks端口（默认1080）及开启服务 2. 修改配置文件1sudo vim /usr/local/etc/privoxy/config 所有请求通过socks5中转，127.0.0.1:1080代表shadowsocks本地监听的地址和端口privoxy监听本地的8118端口 3. 启动1234#打开sudo /Applications/Privoxy/startPrivoxy.sh#关闭sudo /Applications/Privoxy/stopPrivoxy.sh 4. 检查1234#查看端口netstat -an | grep 8118#程序运行ps -ef|grep privoxy 5. 测试1curl --connect-timeout 2 -x 127.0.0.1:8118 http://google.com 返回如下代表成功123456&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;301 Moved&lt;/H1&gt;The document has moved&lt;A HREF=\"http://www.google.com/\"&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt; 软件使用代理 代码使用代理 privoxy更多用法自行发掘！","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"web","slug":"web","permalink":"https://linsage.com/tags/web/"}]},{"title":"微信小程序-会话管理","date":"2017-06-12T06:44:25.000Z","path":"2017/06/12/技术/微信小程序-会话管理/","text":"通过微信，小程序以微信账号授权方式进行登录，以用户为核心，减少繁琐注册和输入密码操作，降低用户使用成本。会话管理，大致包含用户登录以及维护用户的登录状态。 处理用户登录 简化流程 小程序：客户端 业务服务器、会话服务器：服务端 客户端，发起wx.login获得code 客户端，发起wx.getUserInfo获得encryptedData、iv 服务端，发送参数（code、encryptedData、iv)，请求微信服务器得到openid，解密出用户信息，完成自动注册及登录保持。 服务端，用户信息key-value方式保存到redis或者缓存服务（充当session）上，key返回给小程序端。 客户端，接受返回用户信息和key，保存到本地缓存localstorage 交换请求，带上key进行登录鉴权 服务端登录代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 登录 */ @Clear public void login() &#123; try &#123; String code = getHeader(\"X-WX-Code\"); String encryptData = getHeader(\"X-WX-Encrypted-Data\"); String iv = getHeader(\"X-WX-IV\"); String url = String.format(\"https://api.weixin.qq.com/sns/jscode2session?appid=%s&amp;secret=%s&amp;js_code=%s&amp;grant_type=authorization_code\", Constant.WX.appId, Constant.WX.appSecret, code); //获取openid+session_key String return_message = HttpKit.get(url); HashMap&lt;String, String&gt; map = new FastJson().parse(return_message, HashMap.class); String openid = map.get(\"openid\"); String session_key = map.get(\"session_key\"); if (StringKit.isNotEmpty(openid) &amp;&amp; StringKit.isNotEmpty(session_key)) &#123; //返回结果 //生成skey String skey = HashKit.md5(DateKit.getCurrentUnixTime() + \"\" + (new Random().nextInt(1000000) + 1)); //用户信息 String user_info = decrypt(encryptData, session_key, iv); WxUserInfoDto wxUserInfoDto = new FastJson().parse(user_info, WxUserInfoDto.class); //检查是否注册？ Account account = AccountService.service.findByWXOpenId(wxUserInfoDto.getOpenId()); if (account == null) &#123; //自动注册 account = new Account(); account.setId(UUID.randomUUID().toString()); account.setSource(SourceEnum.WX.getValue()); account.setWxOpenId(wxUserInfoDto.getOpenId()); account.setUsername(\"wx_\" + wxUserInfoDto.getOpenId()); // \"wx_\"+openid account.setSalt(EncryptKit.salt()); account.setPwd(EncryptKit.encryptPassword(\"123456\", account.getSalt())); account.setCreateDate(new Date()); account.setRegisterDate(new Date()); account.setAvatar(wxUserInfoDto.getAvatarUrl()); account.setNickname(wxUserInfoDto.getNickName()); account.setGender(wxUserInfoDto.getGender()); account.setStat(StatEnum.Enabled.getValue()); account.setIsAdmin(0); account.save(); &#125; else &#123; //返回用户 //更新登录时间 account.setLatestLoginDate(new Date()); account.update(); &#125; CacheKit.put(Constant.CacheName.loginUser, skey, account); renderJson(KV.by(\"skey\", skey).set(\"userInfo\", account)); &#125; else &#123; throw new WxRuntimeException(\"登录请求参数错误\"); &#125; &#125; catch (WxRuntimeException e) &#123; //业务错误 getResponse().setStatus(299); renderJson(KV.by(\"message\", e.getMessage())); &#125; catch (Exception e) &#123; //异常 log.error(e.getMessage()); getResponse().setStatus(500); renderJson(KV.by(\"message\", e.getMessage())); &#125; &#125; 参考资料 微信小程序开源全栈基础项目：https://github.com/tencentyun/wafer 微信小程序api：https://mp.weixin.qq.com/debug/wxadoc/dev/api/","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://linsage.com/tags/微信小程序/"}]},{"title":"TamperMonkey使用","date":"2017-06-11T08:40:53.000Z","path":"2017/06/11/技术/TamperMonkey使用/","text":"TamperMonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它的作用就是让浏览器运行特殊的JS脚本，从而实现更多功能。 下载插件 http://tampermonkey.net/ （chrome为示例） 安装网上提供脚本 https://greasyfork.org/zh-CN网上提供各种好用的脚本，例如：百度网盘直接下载助手、去广告插件…. 创建自定义脚本需求：获取instagram指个账号所有内容列表json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ==UserScript==// @name 获取ins列表json// @namespace http://linsage.xyz/// @version 0.1// @description 获取ins列表json// @author You// @match https://www.instagram.com/*/// @grant GM_xmlhttpRequest// @require https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js// ==/UserScript==$(document).ready(function() &#123; //https://www.instagram.com/&#123;username&#125;/?__a=1 var url=window.location.toString(); var username=url.split(\"/\")[3]; console.info(username); //1.通过username获取userid GM_xmlhttpRequest(&#123; method: \"GET\", url:\"https://www.instagram.com/\"+username+\"/?__a=1\", onload: function(response) &#123; var jsonObj =eval(\"(\"+response.responseText+\")\"); var userid=jsonObj.user.id; console.info(userid); //2.获取内容 GM_xmlhttpRequest(&#123; method: \"GET\", url:\"https://www.instagram.com/graphql/query/?query_id=17880160963012870&amp;id=\"+userid+\"&amp;first=999\", onload: function(result) &#123; var contentObj =eval(\"(\"+result.responseText+\")\"); console.info(contentObj); var photo=[]; for (var i = 0; i&lt; contentObj.data.user.edge_owner_to_timeline_media.edges.length; i++) &#123; var node=contentObj.data.user.edge_owner_to_timeline_media.edges[i].node; photo.push(node); &#125; var str=JSON.stringify(photo) ; console.info(str); var x = window.open(); x.document.open(); x.document.write('&lt;html&gt;&lt;body&gt;&lt;pre&gt;' + str + '&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;'); x.document.close(); &#125; &#125;); &#125; &#125;);&#125;); @match 匹配url规则下，使用应用当前脚本 @require 地址引入jQuery @grant 使用加强函数 GM_xmlhttpRequest GM_xmlhttpRequest：相当于$.ajax用法，发起异步ajax，由于安全限制以此方式发起，并且同域请求（跨域请求每次会提示授权发起） 效果 https://www.instagram.com/用户名/","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"chrome","slug":"chrome","permalink":"https://linsage.com/tags/chrome/"}]},{"title":"想法与行动","date":"2017-02-01T12:24:03.000Z","path":"2017/02/01/生活/想法与行动/","text":"宝贵时间不能只用来看剧、玩游戏。要跳出自身的循环，必须努力break一次。既然不甘于平庸，就要努力而不止停留于想法，重要是行动。“做事情切忌纠结，先run起来，然后慢慢改进，太多雄心壮志的项目，纠结纠结人就老了，还没做出来。”","tags":[{"name":"生活","slug":"生活","permalink":"https://linsage.com/tags/生活/"}]},{"title":"Jfinal整合Druid","date":"2017-01-30T14:45:51.000Z","path":"2017/01/30/技术/Jfinal+Druid/","text":"JFinal 是基于 Java 语言的极速 WEB + ORM 框架。Druid 是阿里开源的一个数据库连接池，与传统的c3p0、dbcp等数据库连接池相比，特点在于其强大监控功能。下面演示配置过程。 相关 IntelliJ IDEA Gradle Jfinal Druid 依赖123456789dependencies &#123; testCompile \"junit:junit:3.8.1\" compile \"com.jfinal:jetty-server:8.1.8\" compile \"com.jfinal:jfinal:3.0\" compile \"log4j:log4j:1.2.16\" compile \"mysql:mysql-connector-java:5.1.20\" compile \"com.jfinal:cos:26Dec2008\" compile 'com.alibaba:druid:1.0.27'&#125; 过程1. 修改web.xmlWebConfig是继承JFinalConfig的启动类 123456789101112131415161718&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;filter&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;filter-class&gt;com.jfinal.core.JFinalFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;configClass&lt;/param-name&gt; &lt;param-value&gt;xyz.linsage.WebConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 2. WebConfig启动类 main 内置jetty方式启动， configConstant，读取相关配置文件 configPlugin，分别加入StatFilter（监控）、WallFilter（防SQL注入）、Log4jFilter（打印SQL日志） configHandler，增加监控平台处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 启动类 * * @author linsage * @create 2017-01-30 下午4:41 */public class WebConfig extends JFinalConfig &#123; private static final int PORT = 8006; private static final String BASE_URL = \"http://localhost:\" + PORT; private static final String WEB_APP = \"src/main/webapp\"; private static final String CONTEXT_PATH = \"/\"; public static void main(String[] args) throws Exception &#123; Server server = new Server(PORT); WebAppContext context = new WebAppContext(WEB_APP, CONTEXT_PATH); server.setHandler(context); server.start(); //打开浏览器 System.out.println(BASE_URL); Desktop.getDesktop().browse(new URI(BASE_URL)); server.join(); &#125; /** * 配置常量 * * @param constants */ @Override public void configConstant(Constants constants) &#123; // 加载少量必要配置，随后可用getProperty(...)获取值 loadPropertyFile(\"config.properties\"); constants.setDevMode(getPropertyToBoolean(\"devMode\", true)); &#125; /** * 配置路由 * * @param routes */ public void configRoute(Routes routes) &#123; routes.add(\"/\", HomeController.class); &#125; @Override public void configEngine(Engine me) &#123; &#125; /** * 配置插件 * * @param plugins */ @Override public void configPlugin(Plugins plugins) &#123; // 配置druid数据库连接池插件 DruidPlugin druidPlugin = new DruidPlugin(getProperty(\"jdbcUrl\"), getProperty(\"user\"), getProperty(\"password\")); druidPlugin.setInitialSize(getPropertyToInt(\"druid.InitialSize\", 10)); druidPlugin.setMinIdle(getPropertyToInt(\"druid.MinIdle\", 10)); druidPlugin.setMaxActive(getPropertyToInt(\"druid.MaxActive\", 100)); //监控 StatFilter statFilter = new StatFilter(); statFilter.setLogSlowSql(getPropertyToBoolean(\"druid.logSlowSql\", false)); statFilter.setSlowSqlMillis(getPropertyToInt(\"druid.slowSqlMillis\",3*1000)); druidPlugin.addFilter(statFilter); //防注入 WallFilter wallFilter = new WallFilter(); wallFilter.setDbType(\"mysql\"); druidPlugin.addFilter(wallFilter); //日志 Log4jFilter log4jFilter = new Log4jFilter(); log4jFilter.setDataSourceLogEnabled(false); log4jFilter.setConnectionLogEnabled(false); log4jFilter.setStatementLogEnabled(false); log4jFilter.setResultSetLogEnabled(false); log4jFilter.setStatementExecutableSqlLogEnable(true); //只开启执行sql druidPlugin.addFilter(log4jFilter); plugins.add(druidPlugin); // 配置ActiveRecord插件 ActiveRecordPlugin arp = new ActiveRecordPlugin(druidPlugin); arp.addMapping(\"user\", User.class); //arp.setShowSql(true); plugins.add(arp); &#125; /** * 配置全局拦截器 * * @param interceptors */ @Override public void configInterceptor(Interceptors interceptors) &#123; &#125; /** * 配置处理器 * * @param handlers */ @Override public void configHandler(Handlers handlers) &#123; DruidStatViewHandler dvh = new DruidStatViewHandler(getProperty(\"druid.visitPath\")); handlers.add(dvh); &#125;&#125; 3. 项目配置config.properties12345678910111213jdbcUrl = jdbc:mysql://127.0.0.1:3306/scaffold?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNulluser = rootpassword = 123456devMode = true#druiddruid.InitialSize = 10druid.MinIdle = 10druid.MaxActive = 100#监控页面druid.visitPath = /zs#慢sqldruid.logSlowSql = truedruid.slowSqlMillis = 3000 4. 日志配置log4j.properties123456789101112131415161718192021222324# 根级别WARN，添加stdout、file输出log4j.rootLogger=WARN, stdout, file# 打印到控制台，日志级别DEBUGlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Threshold=DEBUGlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%n%-d&#123;yyyy-MM-dd HH:mm:ss&#125;%n[%p]-[Thread: %t]-[%C.%M()]: %m%n# 打印到文件，每天一个文件，日志级别WARNlog4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.file.File=./scaffold.loglog4j.appender.file.Threshold=WARNlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%n%-d&#123;yyyy-MM-dd HH:mm:ss&#125;%n[%p]-[Thread: %t]-[%C.%M()]: %m%n# Druid *注意只能配一个值，避免重复打印*log4j.logger.druid.sql=WARNlog4j.logger.druid.sql.DataSource=WARNlog4j.logger.druid.sql.Connection=WARN# 当前执行sql只打印到控制台log4j.logger.druid.sql.Statement=DEBUGlog4j.logger.druid.sql.ResultSet=WARN 打印SQL问题由于jfinal自带打印sql，只能打印，不能打印出参数。改用druid打印，为了避免打印日志重复及过多，只开启执行sql打印及。日志级别，控制台只输出DEBUG级别（打印sql)，实际部署运行文件打印只输出WARN级别 druid监控页面由于通过jfinal直接代码配置，非传统xml配置，登录账户及密码权限验证，需要自定义控制验证，我为了简化，只改变区分一般druid.visitPath来完成安全隐藏。","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"数据库","slug":"数据库","permalink":"https://linsage.com/tags/数据库/"}]},{"title":"Jenkins持续集成","date":"2017-01-16T01:39:38.000Z","path":"2017/01/16/技术/Jenkins持续集成/","text":"原理 测试环境 CI服务器 JDK1.7 Gradle Git 相关文件目录：/home/ci 默认Jenkins运行目录：/root/.jenkins 使用示例1. 安装JDK并配置环境变量（略）1JAVA_HOME=/usr/local/jdk1.7.0_79 2. 安装Gradle（自动化构建工具）(1) 下载gradle2.7 1wget https://services.gradle.org/distributions/gradle-2.7-all.zip (2) 解压 1jar -xvf gradle-2.7-all.zip // 或 unzip gradle-2.7-all.zip (3) 配置环境变量（GRADLE_HOME） 12345vi /etc/profileexport GRADLE_HOME=/home/ci/gradle-2.7export JAVA_HOME=/usr/local/jdk1.7.0_79export PATH=$JAVA_HOME/bin:$PATH:$GRADLE_HOME/binsource /etc/profile 1gradle --version //Gradle 2.7 3. 安装Git（源码管理）(1) 下载并安装Git（版本要求: 1.7.9 minimum, 1.8.x recommended ） 1yum -y install git (2) 升级或者移除并源码安装升级1.7.10教程 123456wget https://github.com/git/git/archive/v2.2.1.tar.gztar -zxvf v2.2.1.tar.gzcd git-2.2.1make configure./configure -prefix=/usr/local/git --with-curl --with-expatmake &amp;&amp; make install (3) 添加到环境变量 1234vi /etc/profileexport GIT_HOME=/usr/local/gitexport PATH=$JAVA_HOME/bin:$PATH:$GRADLE_HOME/bin:$GIT_HOME/libexec/git-coresource /etc/profile 1git --version //git version 2.2.1 4. 安装Jenkins（CI）(1) 下载配置Tomcat容器 1234wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-7/v7.0.64/bin/apache-tomcat-7.0.64.tar.gztar -zxvf apache-tomcat-7.0.64.tar.gz #删除多余自带应用rm -rf apache-tomcat-7.0.64/webapps/* (2) 设置编码UTF-8 1vi apache-tomcat-7.0.64/conf/server.xml 123456&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;```![]()(3) 设置内存（可选，多任务执行下需要） vi apache-tomcat-7.0.64/bin/catalina.sh #!/bin/sh 下面 增加：JAVA_HOME=’/usr/local/jdk1.8’JAVA_OPTS=’-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom’12(4) 下载Jenkins cd apache-tomcat-7.0.64/webapps/mkdir ROOTcd ROOTwget http://mirrors.jenkins-ci.org/war/1.632/jenkins.warjar -xvf jenkins.war // 或 unzip jenkins.war1(5) 防火墙开放8080端口 vi /etc/sysconfig/iptables #jenkis-tomcat-A INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT #重启服务service iptables restart1(6) 设置开机自动启动 vi /etc/rc.local #加入/home/ci/apache-tomcat-7.0.64/bin/startup.sh1(7) 启动Jenkins /home/ci/apache-tomcat-7.0.64/bin/startup.sh``` 4. 配置Jenkins(1) 安全设置(2) 注册一个超级管理员账号(3) 插件安装Git插件Gradle插件远程SSH插件(4) 系统设置JDKGitGradle邮箱通知 5. 配置远程服务器 6.构建任务（1）创建任务（2）源码配置（3）gradle编译（4）查看工作区（5）部署（6）邮件通知","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"ci","slug":"ci","permalink":"https://linsage.com/tags/ci/"}]},{"title":"提高终端的颜值","date":"2016-12-19T03:40:17.000Z","path":"2016/12/19/技术/提高终端的颜值/","text":"程序员长期面对命令行终端和代码编写器，一套看着舒服、自己喜爱的编程字体和配色方案，能提高工作效率，享受编程乐趣。因为每个人喜好不一样，没有唯一的，只有适合自己的。 编程字体 Droid Sans Mono：Google的Droid字体家族中一员，专门用来开发Android平台上的应用 Monaco：Mac平台，默认字体，个人最喜欢的编程字体 Consolas：是商业字体，专门为微软设计。 Source Code Pro：Adobe公司开放的英文开源字集，适用於Linux、Mac OS X和Windows Courier New：Courier 的一个变体，由 Adrian Frutiger 为 IBM 打字机设计的。 Solarized配色方案 跨平台的配色方案，支持多种编辑器和IDE，如Vim，iTerm2、IntelliJ IDEA…。背景色分dark和light，个人偏好light。官方介绍 SecretCRT配色方案由于SecretCRT商业软件，暂时没有Solarized配色支持，ssh操作不可避免使用的软件。 SecretCRT配色方案","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"vim","slug":"vim","permalink":"https://linsage.com/tags/vim/"}]},{"title":"使用Hexo+Github搭建个人博客","date":"2016-12-15T02:03:13.000Z","path":"2016/12/15/技术/使用Hexo+Github搭建博客/","text":"开篇之作，一直想写些技术与学习相关的文章分享。向别人讲述一个知识学习方法和经验，分享总是比个人单纯学会要难，需要考虑很多东西，包括学习方法、遇到问题、讲述方式、写作手法等。与别人分享知识的过程，同时也是个人学习的过程。 预备知识 Git基础命令使用 Github使用 Hexo安装与使用 Markdown语法 搭建过程一、GitHub Pages专属于个人的静态网页托管项目，稳定可靠，官网介绍。 1. 注册GitHub。创建用户名一个username.github.io。username-实际用户名。 2. 配置项目信息 3. 通过git下载本地1git clone https://github.com/username/username.github.io 4. 创建默认页创建index.html页面，git推到远程服务器 5. 浏览 http://linsage.github.io 二、Hexo博客框架Hexo 是一个快速、简洁且高效的博客框架，最终生成静态网页，官网介绍。 1. 安装Hexo安装介绍1npm install -g hexo-cli 2. hexo命令12345hexo init #初始化hexo g #生成静态网页hexo s #启动服务，默认4000端口hexo d #部署hexo n #写文章 3. 选择yilia主题hexo提供很多主题选择，根据喜好选择。修改hexo根目录下的 _config.yml ： theme: yiliayilia主题 4. 部署到github三、域名解析域名推荐到阿里云或者godaddy购买，国内需要实名认证后才能正常解析。linsage.xyz域名下，子域名blog，相当于linsage.xyz增加CNAME记录增加CNAME文件 等1分钟后，访问 http://linsage.xyz 即可 相关软件 MacOS MWeb，专注于markdown语法编辑器。 iPic，图床上传工具 坚果云同步盘","tags":[{"name":"技术","slug":"技术","permalink":"https://linsage.com/tags/技术/"},{"name":"hexo","slug":"hexo","permalink":"https://linsage.com/tags/hexo/"}]}]